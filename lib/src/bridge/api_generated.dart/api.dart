// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'domain/heart_rate.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_hr_stream_receiver`, `get_or_create_hr_broadcast_sender`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `FlutterLogWriter`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `flush`, `fmt`, `make_writer`, `write`

/// Initialize the panic handler for FFI safety.
///
/// This function sets up a panic hook that catches Rust panics and logs them
/// using the tracing framework instead of crashing the app. This is critical
/// for Android/iOS where uncaught panics would terminate the entire application.
///
/// **IMPORTANT**: This function should be called once during Flutter app initialization,
/// before making any other FFI calls to Rust.
///
/// # Examples
///
/// In your Flutter/Dart code:
/// ```dart
/// void main() async {
///   // Initialize Rust panic handler first
///   await RustLib.init();
///   initPanicHandler();
///
///   runApp(MyApp());
/// }
/// ```
Future<void> initPanicHandler() =>
    RustLib.instance.api.crateApiInitPanicHandler();

/// Initialize platform-specific BLE requirements.
///
/// This function performs platform-specific initialization required for BLE operations.
/// On Android, btleplug requires JNI environment initialization before any BLE operations
/// can be performed. On other platforms (Linux, macOS, Windows, iOS), this is a no-op.
///
/// **IMPORTANT**: This function should be called once during Flutter app initialization,
/// after RustLib.init() but before making any BLE API calls (scan_devices, connect_device, etc.).
///
/// # Returns
///
/// Returns Ok(()) if initialization succeeds, or an error if platform-specific setup fails.
///
/// # Errors
///
/// On Android: Returns an error if btleplug platform initialization fails (e.g., missing
/// Bluetooth permissions, BLE hardware unavailable).
///
/// # Examples
///
/// In your Flutter/Dart code:
/// ```dart
/// void main() async {
///   await RustLib.init();
///   await initPlatform(); // Initialize BLE platform
///
///   runApp(MyApp());
/// }
/// ```
Future<void> initPlatform() => RustLib.instance.api.crateApiInitPlatform();

/// Initialize logging and forward Rust tracing logs to Flutter.
///
/// This function sets up a tracing subscriber that captures all Rust log messages
/// (at the level specified by the RUST_LOG environment variable) and forwards them
/// to Flutter via a StreamSink. This enables unified logging for debugging where
/// both Dart and Rust logs can be viewed together.
///
/// **IMPORTANT**: This function should be called once during Flutter app initialization,
/// after RustLib.init() but before making any other FFI calls that generate logs.
///
/// # Arguments
///
/// * `sink` - The FRB StreamSink that will receive log messages
///
/// # Environment Variables
///
/// * `RUST_LOG` - Controls the log level (TRACE, DEBUG, INFO, WARN, ERROR).
///   Defaults to INFO if not set. Example: `RUST_LOG=debug` or `RUST_LOG=heart_beat=trace`
///
/// # Examples
///
/// In your Flutter/Dart code:
/// ```dart
/// void main() async {
///   await RustLib.init();
///
///   // Create a stream to receive logs
///   final logStream = StreamController<LogMessage>();
///   initLogging(sink: logStream.sink);
///
///   // Listen to logs
///   logStream.stream.listen((log) {
///     debugPrint('[${log.level}] ${log.target}: ${log.message}');
///   });
///
///   runApp(MyApp());
/// }
/// ```
Stream<LogMessage> initLogging() => RustLib.instance.api.crateApiInitLogging();

/// Scan for BLE heart rate devices.
///
/// Initiates a BLE scan and returns all discovered devices advertising
/// the Heart Rate Service (UUID 0x180D).
///
/// # Returns
///
/// A list of discovered devices with their IDs, names, and signal strength.
///
/// # Errors
///
/// Returns an error if:
/// - BLE adapter initialization fails
/// - Scan operation fails
/// - BLE is not available or permissions are missing
Future<List<DiscoveredDevice>> scanDevices() =>
    RustLib.instance.api.crateApiScanDevices();

/// Connect to a BLE heart rate device.
///
/// Establishes a connection to the specified device and transitions the
/// connectivity state machine to the Connected state.
///
/// # Arguments
///
/// * `device_id` - Platform-specific device identifier from scan results
///
/// # Errors
///
/// Returns an error if:
/// - Device is not found
/// - Connection fails
/// - Connection timeout (15 seconds)
Future<void> connectDevice({required String deviceId}) =>
    RustLib.instance.api.crateApiConnectDevice(deviceId: deviceId);

/// Disconnect from the currently connected device.
///
/// Gracefully disconnects from the active BLE connection and transitions
/// the state machine back to Idle.
///
/// # Errors
///
/// Returns an error if disconnection fails or no device is connected.
Future<void> disconnect() => RustLib.instance.api.crateApiDisconnect();

/// Start mock mode for testing without hardware.
///
/// Activates the mock adapter which generates simulated heart rate data.
/// Useful for UI development and testing without a physical device.
///
/// # Errors
///
/// Returns an error if mock mode activation fails.
Future<void> startMockMode() => RustLib.instance.api.crateApiStartMockMode();

/// Create a stream for receiving filtered heart rate data.
///
/// Sets up a stream that will receive real-time filtered heart rate measurements
/// from the filtering pipeline. This function is used by Flutter via FRB to
/// create a reactive data stream.
///
/// # Arguments
///
/// * `sink` - The FRB StreamSink that will receive the HR data
///
/// # Returns
///
/// Returns Ok(()) if the stream was successfully set up.
Stream<ApiFilteredHeartRate> createHrStream() =>
    RustLib.instance.api.crateApiCreateHrStream();

/// Emit filtered heart rate data to all stream subscribers.
///
/// This function should be called by the filtering pipeline when new filtered
/// HR data is available. It broadcasts the data to all active stream subscribers.
///
/// # Arguments
///
/// * `data` - The filtered heart rate measurement to broadcast
///
/// # Returns
///
/// The number of receivers that received the data. Returns 0 if no receivers
/// are currently subscribed.
///
/// # Example
///
/// ```rust,ignore
/// // In your filtering pipeline:
/// let filtered_data = FilteredHeartRate { /* ... */ };
/// emit_hr_data(filtered_data);
/// ```
Future<BigInt> emitHrData({required ApiFilteredHeartRate data}) =>
    RustLib.instance.api.crateApiEmitHrData(data: data);

/// Get the raw (unfiltered) BPM value from filtered heart rate data
Future<int> hrRawBpm({required ApiFilteredHeartRate data}) =>
    RustLib.instance.api.crateApiHrRawBpm(data: data);

/// Get the filtered BPM value from filtered heart rate data
Future<int> hrFilteredBpm({required ApiFilteredHeartRate data}) =>
    RustLib.instance.api.crateApiHrFilteredBpm(data: data);

/// Get the RMSSD heart rate variability metric in milliseconds
Future<double?> hrRmssd({required ApiFilteredHeartRate data}) =>
    RustLib.instance.api.crateApiHrRmssd(data: data);

/// Get the battery level as a percentage (0-100)
Future<int?> hrBatteryLevel({required ApiFilteredHeartRate data}) =>
    RustLib.instance.api.crateApiHrBatteryLevel(data: data);

/// Get the timestamp in milliseconds since Unix epoch
Future<BigInt> hrTimestamp({required ApiFilteredHeartRate data}) =>
    RustLib.instance.api.crateApiHrTimestamp(data: data);

/// Calculate the heart rate zone based on a maximum heart rate
///
/// # Arguments
///
/// * `data` - The filtered heart rate data
/// * `max_hr` - The user's maximum heart rate
///
/// # Returns
///
/// The training zone (Zone1-Zone5) based on percentage of max HR
Future<Zone> hrZone({required ApiFilteredHeartRate data, required int maxHr}) =>
    RustLib.instance.api.crateApiHrZone(data: data, maxHr: maxHr);

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiFilteredHeartRate>>
abstract class ApiFilteredHeartRate implements RustOpaqueInterface {}

/// Log message that can be sent to Flutter for debugging.
///
/// This struct represents a single log entry with level, target module,
/// timestamp, and message content. It's designed to be sent across the FFI
/// boundary to Flutter for display in the debug console.
class LogMessage {
  /// Log level (TRACE, DEBUG, INFO, WARN, ERROR)
  final String level;

  /// Module path where the log originated (e.g., "heart_beat::adapters")
  final String target;

  /// Timestamp in milliseconds since Unix epoch
  final BigInt timestamp;

  /// The actual log message
  final String message;

  const LogMessage({
    required this.level,
    required this.target,
    required this.timestamp,
    required this.message,
  });

  @override
  int get hashCode =>
      level.hashCode ^ target.hashCode ^ timestamp.hashCode ^ message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LogMessage &&
          runtimeType == other.runtimeType &&
          level == other.level &&
          target == other.target &&
          timestamp == other.timestamp &&
          message == other.message;
}

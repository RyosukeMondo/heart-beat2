// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'domain/heart_rate.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `create_session_progress_forwarder`, `get_battery_stream_receiver`, `get_ble_adapter`, `get_connection_status_receiver`, `get_hr_stream_receiver`, `get_or_create_battery_broadcast_sender`, `get_or_create_connection_status_broadcast_sender`, `get_or_create_hr_broadcast_sender`, `get_or_create_session_progress_broadcast_sender`, `get_session_executor`, `get_session_progress_receiver`, `get_session_repository`, `load_plan`
// These functions are ignored because they have generic arguments: `notify`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `FlutterLogWriter`, `StubNotificationPort`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `flush`, `fmt`, `fmt`, `fmt`, `make_writer`, `write`

/// Initialize the panic handler for FFI safety.
///
/// This function sets up a panic hook that catches Rust panics and logs them
/// using the tracing framework instead of crashing the app. This is critical
/// for Android/iOS where uncaught panics would terminate the entire application.
///
/// **IMPORTANT**: This function should be called once during Flutter app initialization,
/// before making any other FFI calls to Rust.
///
/// # Examples
///
/// In your Flutter/Dart code:
/// ```dart
/// void main() async {
///   // Initialize Rust panic handler first
///   await RustLib.init();
///   initPanicHandler();
///
///   runApp(MyApp());
/// }
/// ```
Future<void> initPanicHandler() =>
    RustLib.instance.api.crateApiInitPanicHandler();

/// Initialize platform-specific BLE requirements.
///
/// This function performs platform-specific initialization required for BLE operations.
/// On Android, btleplug requires JNI environment initialization before any BLE operations
/// can be performed. On other platforms (Linux, macOS, Windows, iOS), this is a no-op.
///
/// **IMPORTANT**: This function should be called once during Flutter app initialization,
/// after RustLib.init() but before making any BLE API calls (scan_devices, connect_device, etc.).
///
/// # Returns
///
/// Returns Ok(()) if initialization succeeds, or an error if platform-specific setup fails.
///
/// # Errors
///
/// On Android: Returns an error if btleplug platform initialization fails (e.g., missing
/// Bluetooth permissions, BLE hardware unavailable).
///
/// # Examples
///
/// In your Flutter/Dart code:
/// ```dart
/// void main() async {
///   await RustLib.init();
///   await initPlatform(); // Initialize BLE platform
///
///   runApp(MyApp());
/// }
/// ```
Future<void> initPlatform() => RustLib.instance.api.crateApiInitPlatform();

/// Initialize logging and forward Rust tracing logs to Flutter.
///
/// This function sets up a tracing subscriber that captures all Rust log messages
/// (at the level specified by the RUST_LOG environment variable) and forwards them
/// to Flutter via a StreamSink. This enables unified logging for debugging where
/// both Dart and Rust logs can be viewed together.
///
/// **IMPORTANT**: This function should be called once during Flutter app initialization,
/// after RustLib.init() but before making any other FFI calls that generate logs.
///
/// # Arguments
///
/// * `sink` - The FRB StreamSink that will receive log messages
///
/// # Environment Variables
///
/// * `RUST_LOG` - Controls the log level (TRACE, DEBUG, INFO, WARN, ERROR).
///   Defaults to INFO if not set. Example: `RUST_LOG=debug` or `RUST_LOG=heart_beat=trace`
///
/// # Examples
///
/// In your Flutter/Dart code:
/// ```dart
/// void main() async {
///   await RustLib.init();
///
///   // Create a stream to receive logs
///   final logStream = StreamController<LogMessage>();
///   initLogging(sink: logStream.sink);
///
///   // Listen to logs
///   logStream.stream.listen((log) {
///     debugPrint('[${log.level}] ${log.target}: ${log.message}');
///   });
///
///   runApp(MyApp());
/// }
/// ```
Stream<LogMessage> initLogging() => RustLib.instance.api.crateApiInitLogging();

/// Scan for BLE heart rate devices.
///
/// Initiates a BLE scan and returns all discovered devices advertising
/// the Heart Rate Service (UUID 0x180D).
///
/// # Returns
///
/// A list of discovered devices with their IDs, names, and signal strength.
///
/// # Errors
///
/// Returns an error if:
/// - BLE adapter initialization fails
/// - Scan operation fails
/// - BLE is not available or permissions are missing
Future<List<DiscoveredDevice>> scanDevices() =>
    RustLib.instance.api.crateApiScanDevices();

/// Connect to a BLE heart rate device.
///
/// Establishes a connection to the specified device and transitions the
/// connectivity state machine to the Connected state.
///
/// # Arguments
///
/// * `device_id` - Platform-specific device identifier from scan results
///
/// # Errors
///
/// Returns an error if:
/// - Device is not found
/// - Connection fails
/// - Connection timeout (15 seconds)
Future<void> connectDevice({required String deviceId}) =>
    RustLib.instance.api.crateApiConnectDevice(deviceId: deviceId);

/// Disconnect from the currently connected device.
///
/// Gracefully disconnects from the active BLE connection and transitions
/// the state machine back to Idle.
///
/// # Errors
///
/// Returns an error if disconnection fails or no device is connected.
Future<void> disconnect() => RustLib.instance.api.crateApiDisconnect();

/// Start mock mode for testing without hardware.
///
/// Activates the mock adapter which generates simulated heart rate data.
/// Useful for UI development and testing without a physical device.
///
/// # Errors
///
/// Returns an error if mock mode activation fails.
Future<void> startMockMode() => RustLib.instance.api.crateApiStartMockMode();

/// Create a stream for receiving filtered heart rate data.
///
/// Sets up a stream that will receive real-time filtered heart rate measurements
/// from the filtering pipeline. This function is used by Flutter via FRB to
/// create a reactive data stream.
///
/// # Arguments
///
/// * `sink` - The FRB StreamSink that will receive the HR data
///
/// # Returns
///
/// Returns Ok(()) if the stream was successfully set up.
Stream<ApiFilteredHeartRate> createHrStream() =>
    RustLib.instance.api.crateApiCreateHrStream();

/// Emit filtered heart rate data to all stream subscribers.
///
/// This function should be called by the filtering pipeline when new filtered
/// HR data is available. It broadcasts the data to all active stream subscribers.
///
/// # Arguments
///
/// * `data` - The filtered heart rate measurement to broadcast
///
/// # Returns
///
/// The number of receivers that received the data. Returns 0 if no receivers
/// are currently subscribed.
///
/// # Example
///
/// ```rust,ignore
/// // In your filtering pipeline:
/// let filtered_data = FilteredHeartRate { /* ... */ };
/// emit_hr_data(filtered_data);
/// ```
Future<BigInt> emitHrData({required ApiFilteredHeartRate data}) =>
    RustLib.instance.api.crateApiEmitHrData(data: data);

/// Get the raw (unfiltered) BPM value from filtered heart rate data
Future<int> hrRawBpm({required ApiFilteredHeartRate data}) =>
    RustLib.instance.api.crateApiHrRawBpm(data: data);

/// Get the filtered BPM value from filtered heart rate data
Future<int> hrFilteredBpm({required ApiFilteredHeartRate data}) =>
    RustLib.instance.api.crateApiHrFilteredBpm(data: data);

/// Get the RMSSD heart rate variability metric in milliseconds
Future<double?> hrRmssd({required ApiFilteredHeartRate data}) =>
    RustLib.instance.api.crateApiHrRmssd(data: data);

/// Get the battery level as a percentage (0-100)
Future<int?> hrBatteryLevel({required ApiFilteredHeartRate data}) =>
    RustLib.instance.api.crateApiHrBatteryLevel(data: data);

/// Get the timestamp in milliseconds since Unix epoch
Future<BigInt> hrTimestamp({required ApiFilteredHeartRate data}) =>
    RustLib.instance.api.crateApiHrTimestamp(data: data);

/// Calculate the heart rate zone based on a maximum heart rate
///
/// # Arguments
///
/// * `data` - The filtered heart rate data
/// * `max_hr` - The user's maximum heart rate
///
/// # Returns
///
/// The training zone (Zone1-Zone5) based on percentage of max HR
Future<Zone> hrZone({required ApiFilteredHeartRate data, required int maxHr}) =>
    RustLib.instance.api.crateApiHrZone(data: data, maxHr: maxHr);

/// Create a dummy battery level for testing (temporary helper for FRB codegen).
///
/// This function helps FRB discover the ApiBatteryLevel type during code generation.
/// TODO: Remove this after ApiBatteryLevel is properly integrated.
Future<ApiBatteryLevel> dummyBatteryLevelForCodegen() =>
    RustLib.instance.api.crateApiDummyBatteryLevelForCodegen();

/// Create a dummy connection status for testing (temporary helper for FRB codegen).
///
/// This function helps FRB discover the ApiConnectionStatus type during code generation.
Future<ApiConnectionStatus> dummyConnectionStatusForCodegen() =>
    RustLib.instance.api.crateApiDummyConnectionStatusForCodegen();

/// Create a stream for receiving battery level data.
///
/// Sets up a stream that will receive real-time battery level measurements
/// from the connected BLE device. This function is used by Flutter via FRB to
/// create a reactive data stream.
///
/// # Arguments
///
/// * `sink` - The FRB StreamSink that will receive the battery data
///
/// # Returns
///
/// Returns Ok(()) if the stream was successfully set up.
Stream<ApiBatteryLevel> createBatteryStream() =>
    RustLib.instance.api.crateApiCreateBatteryStream();

/// Emit battery level data to all stream subscribers.
///
/// This function should be called by the battery polling task when new battery
/// data is available. It broadcasts the data to all active stream subscribers.
///
/// # Arguments
///
/// * `data` - The battery level measurement to broadcast
///
/// # Returns
///
/// The number of receivers that received the data. Returns 0 if no receivers
/// are currently subscribed.
///
/// # Example
///
/// ```rust,ignore
/// // In your battery polling task:
/// let battery_data = BatteryLevel { /* ... */ };
/// emit_battery_data(battery_data);
/// ```
Future<BigInt> emitBatteryData({required ApiBatteryLevel data}) =>
    RustLib.instance.api.crateApiEmitBatteryData(data: data);

/// Create a stream of session progress updates during workout execution.
///
/// This stream emits SessionProgress updates at regular intervals (typically 1Hz)
/// while a workout is running, providing real-time feedback on phase progress,
/// zone status, and elapsed/remaining time.
///
/// # Arguments
///
/// * `sink` - The FRB StreamSink that will receive the session progress data
///
/// # Returns
///
/// Returns Ok(()) if the stream was successfully set up.
///
/// # Example
///
/// ```dart
/// // In Flutter:
/// final stream = await api.createSessionProgressStream();
/// stream.listen((progress) {
///   print('Current phase: ${progress.phaseProgress.phaseName}');
///   print('Zone status: ${progress.zoneStatus}');
/// });
/// ```
Stream<ApiSessionProgress> createSessionProgressStream() =>
    RustLib.instance.api.crateApiCreateSessionProgressStream();

/// Emit session progress data to all stream subscribers.
///
/// This function is called by the SessionExecutor tick loop when progress updates
/// are available. It broadcasts the data to all active stream subscribers.
///
/// # Arguments
///
/// * `data` - The session progress snapshot to broadcast
///
/// # Returns
///
/// The number of receivers that received the data. Returns 0 if no receivers
/// are currently subscribed.
Future<BigInt> emitSessionProgress({required ApiSessionProgress data}) =>
    RustLib.instance.api.crateApiEmitSessionProgress(data: data);

/// Create a stream for receiving connection status updates.
///
/// Sets up a stream that will receive real-time connection status updates
/// during BLE device connection, reconnection attempts, and failures.
/// This function is used by Flutter via FRB to create a reactive data stream.
///
/// # Arguments
///
/// * `sink` - The FRB StreamSink that will receive the connection status data
///
/// # Returns
///
/// Returns Ok(()) if the stream was successfully set up.
///
/// # Example
///
/// ```dart
/// // In Flutter:
/// final stream = await api.createConnectionStatusStream();
/// stream.listen((status) {
///   if (status.type == 'reconnecting') {
///     print('Reconnecting... attempt ${status.attempt}/${status.max_attempts}');
///   } else if (status.type == 'connected') {
///     print('Connected to ${status.device_id}');
///   }
/// });
/// ```
Stream<ApiConnectionStatus> createConnectionStatusStream() =>
    RustLib.instance.api.crateApiCreateConnectionStatusStream();

/// Emit connection status data to all stream subscribers.
///
/// This function should be called by the BLE adapter when connection status changes.
/// It broadcasts the status to all active stream subscribers.
///
/// # Arguments
///
/// * `status` - The connection status to broadcast
///
/// # Returns
///
/// The number of receivers that received the status. Returns 0 if no receivers
/// are currently subscribed.
///
/// # Example
///
/// ```rust,ignore
/// // When starting reconnection:
/// emit_connection_status(ConnectionStatus::Reconnecting { attempt: 1, max_attempts: 5 });
///
/// // When connected:
/// emit_connection_status(ConnectionStatus::Connected { device_id: "AA:BB:CC:DD:EE:FF".to_string() });
///
/// // When reconnection fails:
/// emit_connection_status(ConnectionStatus::ReconnectFailed { reason: "Max attempts exceeded".to_string() });
/// ```
Future<BigInt> emitConnectionStatus({required ApiConnectionStatus status}) =>
    RustLib.instance.api.crateApiEmitConnectionStatus(status: status);

/// Check if the connection status is Disconnected.
Future<bool> connectionStatusIsDisconnected({
  required ApiConnectionStatus status,
}) =>
    RustLib.instance.api.crateApiConnectionStatusIsDisconnected(status: status);

/// Check if the connection status is Connecting.
Future<bool> connectionStatusIsConnecting({
  required ApiConnectionStatus status,
}) => RustLib.instance.api.crateApiConnectionStatusIsConnecting(status: status);

/// Check if the connection status is Connected.
Future<bool> connectionStatusIsConnected({
  required ApiConnectionStatus status,
}) => RustLib.instance.api.crateApiConnectionStatusIsConnected(status: status);

/// Check if the connection status is Reconnecting.
Future<bool> connectionStatusIsReconnecting({
  required ApiConnectionStatus status,
}) =>
    RustLib.instance.api.crateApiConnectionStatusIsReconnecting(status: status);

/// Check if the connection status is ReconnectFailed.
Future<bool> connectionStatusIsReconnectFailed({
  required ApiConnectionStatus status,
}) => RustLib.instance.api.crateApiConnectionStatusIsReconnectFailed(
  status: status,
);

/// Get the device ID from a Connected status.
/// Returns None if the status is not Connected.
Future<String?> connectionStatusDeviceId({
  required ApiConnectionStatus status,
}) => RustLib.instance.api.crateApiConnectionStatusDeviceId(status: status);

/// Get the current attempt number from a Reconnecting status.
/// Returns None if the status is not Reconnecting.
Future<int?> connectionStatusAttempt({required ApiConnectionStatus status}) =>
    RustLib.instance.api.crateApiConnectionStatusAttempt(status: status);

/// Get the max attempts from a Reconnecting status.
/// Returns None if the status is not Reconnecting.
Future<int?> connectionStatusMaxAttempts({
  required ApiConnectionStatus status,
}) => RustLib.instance.api.crateApiConnectionStatusMaxAttempts(status: status);

/// Get the failure reason from a ReconnectFailed status.
/// Returns None if the status is not ReconnectFailed.
Future<String?> connectionStatusFailureReason({
  required ApiConnectionStatus status,
}) =>
    RustLib.instance.api.crateApiConnectionStatusFailureReason(status: status);

/// Convert connection status to a human-readable string.
Future<String> connectionStatusToString({
  required ApiConnectionStatus status,
}) => RustLib.instance.api.crateApiConnectionStatusToString(status: status);

/// List all completed training sessions.
///
/// Returns a list of session summaries sorted by start time (most recent first).
/// This is optimized for displaying in a list view - full session data is not loaded.
///
/// # Returns
///
/// A vector of session summary previews containing ID, plan name, start time,
/// duration, average heart rate, and status.
///
/// # Errors
///
/// Returns an error if the sessions directory cannot be read or if the repository
/// cannot be initialized.
Future<List<ApiSessionSummaryPreview>> listSessions() =>
    RustLib.instance.api.crateApiListSessions();

/// Get a complete session by its ID.
///
/// Loads the full session data including all heart rate samples and statistics.
/// This is intended for displaying detailed session information.
///
/// # Arguments
///
/// * `id` - The unique identifier of the session to retrieve
///
/// # Returns
///
/// The complete session if found, or `None` if no session with the given ID exists.
///
/// # Errors
///
/// Returns an error if the session file cannot be read or parsed, or if the
/// repository cannot be initialized.
Future<ApiCompletedSession?> getSession({required String id}) =>
    RustLib.instance.api.crateApiGetSession(id: id);

/// Delete a session by its ID.
///
/// Permanently removes the session and all its data from storage.
///
/// # Arguments
///
/// * `id` - The unique identifier of the session to delete
///
/// # Errors
///
/// Returns an error if the session file cannot be deleted or if the repository
/// cannot be initialized. Succeeds silently if the session doesn't exist.
Future<void> deleteSession({required String id}) =>
    RustLib.instance.api.crateApiDeleteSession(id: id);

/// Export a session to a specified format.
///
/// Loads a completed session and exports it in the requested format (CSV, JSON, or text summary).
/// The returned string can be saved to a file or shared directly.
///
/// # Arguments
///
/// * `id` - The unique identifier of the session to export
/// * `format` - The desired export format (Csv, Json, or Summary)
///
/// # Returns
///
/// A string containing the exported session data in the requested format.
///
/// # Errors
///
/// Returns an error if:
/// - The session cannot be found
/// - The session repository cannot be initialized
/// - The session data cannot be formatted (should not normally occur)
///
/// # Examples
///
/// ```no_run
/// # use heart_beat::api::{export_session, ExportFormat};
/// # tokio_test::block_on(async {
/// let csv_data = export_session("session-123".to_string(), ExportFormat::Csv).await?;
/// let json_data = export_session("session-123".to_string(), ExportFormat::Json).await?;
/// let summary = export_session("session-123".to_string(), ExportFormat::Summary).await?;
/// # Ok::<(), anyhow::Error>(())
/// # });
/// ```
Future<String> exportSession({
  required String id,
  required ExportFormat format,
}) => RustLib.instance.api.crateApiExportSession(id: id, format: format);

/// Get the session ID from a session summary preview
Future<String> sessionPreviewId({required ApiSessionSummaryPreview preview}) =>
    RustLib.instance.api.crateApiSessionPreviewId(preview: preview);

/// Get the plan name from a session summary preview
Future<String> sessionPreviewPlanName({
  required ApiSessionSummaryPreview preview,
}) => RustLib.instance.api.crateApiSessionPreviewPlanName(preview: preview);

/// Get the start time as Unix timestamp in milliseconds from a session summary preview
Future<PlatformInt64> sessionPreviewStartTime({
  required ApiSessionSummaryPreview preview,
}) => RustLib.instance.api.crateApiSessionPreviewStartTime(preview: preview);

/// Get the duration in seconds from a session summary preview
Future<int> sessionPreviewDurationSecs({
  required ApiSessionSummaryPreview preview,
}) => RustLib.instance.api.crateApiSessionPreviewDurationSecs(preview: preview);

/// Get the average heart rate from a session summary preview
Future<int> sessionPreviewAvgHr({required ApiSessionSummaryPreview preview}) =>
    RustLib.instance.api.crateApiSessionPreviewAvgHr(preview: preview);

/// Get the status string from a session summary preview
Future<String> sessionPreviewStatus({
  required ApiSessionSummaryPreview preview,
}) => RustLib.instance.api.crateApiSessionPreviewStatus(preview: preview);

/// Get the session ID from a completed session
Future<String> sessionId({required ApiCompletedSession session}) =>
    RustLib.instance.api.crateApiSessionId(session: session);

/// Get the plan name from a completed session
Future<String> sessionPlanName({required ApiCompletedSession session}) =>
    RustLib.instance.api.crateApiSessionPlanName(session: session);

/// Get the start time as Unix timestamp in milliseconds from a completed session
Future<PlatformInt64> sessionStartTime({
  required ApiCompletedSession session,
}) => RustLib.instance.api.crateApiSessionStartTime(session: session);

/// Get the end time as Unix timestamp in milliseconds from a completed session
Future<PlatformInt64> sessionEndTime({required ApiCompletedSession session}) =>
    RustLib.instance.api.crateApiSessionEndTime(session: session);

/// Get the status string from a completed session
Future<String> sessionStatus({required ApiCompletedSession session}) =>
    RustLib.instance.api.crateApiSessionStatus(session: session);

/// Get the number of phases completed from a completed session
Future<int> sessionPhasesCompleted({required ApiCompletedSession session}) =>
    RustLib.instance.api.crateApiSessionPhasesCompleted(session: session);

/// Get the duration in seconds from a completed session summary
Future<int> sessionSummaryDurationSecs({
  required ApiCompletedSession session,
}) => RustLib.instance.api.crateApiSessionSummaryDurationSecs(session: session);

/// Get the average heart rate from a completed session summary
Future<int> sessionSummaryAvgHr({required ApiCompletedSession session}) =>
    RustLib.instance.api.crateApiSessionSummaryAvgHr(session: session);

/// Get the maximum heart rate from a completed session summary
Future<int> sessionSummaryMaxHr({required ApiCompletedSession session}) =>
    RustLib.instance.api.crateApiSessionSummaryMaxHr(session: session);

/// Get the minimum heart rate from a completed session summary
Future<int> sessionSummaryMinHr({required ApiCompletedSession session}) =>
    RustLib.instance.api.crateApiSessionSummaryMinHr(session: session);

/// Get the time in zone array from a completed session summary
/// Returns an array of 5 elements representing time spent in each zone (Zone1-Zone5) in seconds
Future<Uint32List> sessionSummaryTimeInZone({
  required ApiCompletedSession session,
}) => RustLib.instance.api.crateApiSessionSummaryTimeInZone(session: session);

/// Get the number of heart rate samples in a completed session
Future<BigInt> sessionHrSamplesCount({required ApiCompletedSession session}) =>
    RustLib.instance.api.crateApiSessionHrSamplesCount(session: session);

/// Get a specific heart rate sample from a completed session
/// Returns a tuple of (timestamp_millis, bpm)
Future<(PlatformInt64, int)?> sessionHrSampleAt({
  required ApiCompletedSession session,
  required BigInt index,
}) => RustLib.instance.api.crateApiSessionHrSampleAt(
  session: session,
  index: index,
);

/// List all available training plans.
///
/// Returns a list of plan names from the ~/.heart-beat/plans/ directory.
/// Each plan is stored as a JSON file named `{plan_name}.json`.
///
/// # Returns
///
/// A vector of plan name strings. Returns an empty vector if no plans are found
/// or if the plans directory doesn't exist yet.
///
/// # Errors
///
/// Returns an error if the home directory cannot be determined or if there are
/// issues reading the plans directory.
Future<List<String>> listPlans() => RustLib.instance.api.crateApiListPlans();

/// Start a workout session with the specified training plan.
///
/// Loads the plan from ~/.heart-beat/plans/{plan_name}.json and starts
/// executing it. The session will emit progress updates via the progress stream
/// and save the completed session to the repository.
///
/// # Arguments
///
/// * `plan_name` - The name of the training plan to execute (without .json extension)
///
/// # Returns
///
/// Returns Ok(()) if the workout started successfully.
///
/// # Errors
///
/// Returns an error if:
/// - The plan file cannot be found or loaded
/// - A workout is already in progress
/// - The executor cannot be initialized
Future<void> startWorkout({required String planName}) =>
    RustLib.instance.api.crateApiStartWorkout(planName: planName);

/// Pause the currently running workout.
///
/// The workout timer stops but the session state is preserved.
/// Call `resume_workout()` to continue from where you left off.
///
/// # Errors
///
/// Returns an error if no workout is currently running or if the executor
/// is not initialized.
Future<void> pauseWorkout() => RustLib.instance.api.crateApiPauseWorkout();

/// Resume a paused workout.
///
/// Continues the workout from where it was paused. The timer resumes
/// counting and progress updates continue.
///
/// # Errors
///
/// Returns an error if no workout is paused or if the executor is not initialized.
Future<void> resumeWorkout() => RustLib.instance.api.crateApiResumeWorkout();

/// Stop the currently running workout.
///
/// Ends the workout and saves the session to the repository. The session
/// will be marked as "Stopped" rather than "Completed".
///
/// # Errors
///
/// Returns an error if no workout is running or if the executor is not initialized.
Future<void> stopWorkout() => RustLib.instance.api.crateApiStopWorkout();

/// Get the current session state from SessionProgress.
Future<ApiSessionState> sessionProgressState({
  required ApiSessionProgress progress,
}) => RustLib.instance.api.crateApiSessionProgressState(progress: progress);

/// Get the current phase index from SessionProgress.
Future<int> sessionProgressCurrentPhase({
  required ApiSessionProgress progress,
}) => RustLib.instance.api.crateApiSessionProgressCurrentPhase(
  progress: progress,
);

/// Get the total elapsed seconds from SessionProgress.
Future<int> sessionProgressTotalElapsedSecs({
  required ApiSessionProgress progress,
}) => RustLib.instance.api.crateApiSessionProgressTotalElapsedSecs(
  progress: progress,
);

/// Get the total remaining seconds from SessionProgress.
Future<int> sessionProgressTotalRemainingSecs({
  required ApiSessionProgress progress,
}) => RustLib.instance.api.crateApiSessionProgressTotalRemainingSecs(
  progress: progress,
);

/// Get the zone status from SessionProgress.
Future<ApiZoneStatus> sessionProgressZoneStatus({
  required ApiSessionProgress progress,
}) =>
    RustLib.instance.api.crateApiSessionProgressZoneStatus(progress: progress);

/// Get the current BPM from SessionProgress.
Future<int> sessionProgressCurrentBpm({required ApiSessionProgress progress}) =>
    RustLib.instance.api.crateApiSessionProgressCurrentBpm(progress: progress);

/// Get the phase progress from SessionProgress.
Future<ApiPhaseProgress> sessionProgressPhaseProgress({
  required ApiSessionProgress progress,
}) => RustLib.instance.api.crateApiSessionProgressPhaseProgress(
  progress: progress,
);

/// Get the phase index from PhaseProgress.
Future<int> phaseProgressPhaseIndex({required ApiPhaseProgress progress}) =>
    RustLib.instance.api.crateApiPhaseProgressPhaseIndex(progress: progress);

/// Get the phase name from PhaseProgress.
Future<String> phaseProgressPhaseName({required ApiPhaseProgress progress}) =>
    RustLib.instance.api.crateApiPhaseProgressPhaseName(progress: progress);

/// Get the target zone from PhaseProgress.
Future<Zone> phaseProgressTargetZone({required ApiPhaseProgress progress}) =>
    RustLib.instance.api.crateApiPhaseProgressTargetZone(progress: progress);

/// Get the elapsed seconds in the current phase from PhaseProgress.
Future<int> phaseProgressElapsedSecs({required ApiPhaseProgress progress}) =>
    RustLib.instance.api.crateApiPhaseProgressElapsedSecs(progress: progress);

/// Get the remaining seconds in the current phase from PhaseProgress.
Future<int> phaseProgressRemainingSecs({required ApiPhaseProgress progress}) =>
    RustLib.instance.api.crateApiPhaseProgressRemainingSecs(progress: progress);

/// Check if the session state is Running.
Future<bool> sessionStateIsRunning({required ApiSessionState state}) =>
    RustLib.instance.api.crateApiSessionStateIsRunning(state: state);

/// Check if the session state is Paused.
Future<bool> sessionStateIsPaused({required ApiSessionState state}) =>
    RustLib.instance.api.crateApiSessionStateIsPaused(state: state);

/// Check if the session state is Completed.
Future<bool> sessionStateIsCompleted({required ApiSessionState state}) =>
    RustLib.instance.api.crateApiSessionStateIsCompleted(state: state);

/// Check if the session state is Stopped.
Future<bool> sessionStateIsStopped({required ApiSessionState state}) =>
    RustLib.instance.api.crateApiSessionStateIsStopped(state: state);

/// Convert SessionState to a string representation.
Future<String> sessionStateToString({required ApiSessionState state}) =>
    RustLib.instance.api.crateApiSessionStateToString(state: state);

/// Check if the zone status is InZone.
Future<bool> zoneStatusIsInZone({required ApiZoneStatus status}) =>
    RustLib.instance.api.crateApiZoneStatusIsInZone(status: status);

/// Check if the zone status is TooLow.
Future<bool> zoneStatusIsTooLow({required ApiZoneStatus status}) =>
    RustLib.instance.api.crateApiZoneStatusIsTooLow(status: status);

/// Check if the zone status is TooHigh.
Future<bool> zoneStatusIsTooHigh({required ApiZoneStatus status}) =>
    RustLib.instance.api.crateApiZoneStatusIsTooHigh(status: status);

/// Convert ZoneStatus to a string representation.
Future<String> zoneStatusToString({required ApiZoneStatus status}) =>
    RustLib.instance.api.crateApiZoneStatusToString(status: status);

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiCompletedSession>>
abstract class ApiCompletedSession implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiConnectionStatus>>
abstract class ApiConnectionStatus implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiFilteredHeartRate>>
abstract class ApiFilteredHeartRate implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiPhaseProgress>>
abstract class ApiPhaseProgress implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiSessionProgress>>
abstract class ApiSessionProgress implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiSessionState>>
abstract class ApiSessionState implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiSessionSummaryPreview>>
abstract class ApiSessionSummaryPreview implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ApiZoneStatus>>
abstract class ApiZoneStatus implements RustOpaqueInterface {}

/// Battery level data for FFI boundary (FRB-compatible).
///
/// This is a simplified version of domain::BatteryLevel that uses u64 timestamps
/// instead of SystemTime to be compatible with Flutter Rust Bridge.
class ApiBatteryLevel {
  /// Battery level as a percentage (0-100).
  final int? level;

  /// Whether the device is currently charging.
  final bool isCharging;

  /// Unix timestamp in milliseconds when this battery level was measured.
  final BigInt timestamp;

  const ApiBatteryLevel({
    this.level,
    required this.isCharging,
    required this.timestamp,
  });

  @override
  int get hashCode => level.hashCode ^ isCharging.hashCode ^ timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiBatteryLevel &&
          runtimeType == other.runtimeType &&
          level == other.level &&
          isCharging == other.isCharging &&
          timestamp == other.timestamp;
}

/// Format for exporting session data.
///
/// Specifies the output format when exporting a completed training session.
enum ExportFormat {
  /// Export as comma-separated values (CSV) with timestamp, bpm, and zone columns
  csv,

  /// Export as pretty-printed JSON containing the full session structure
  json,

  /// Export as human-readable text summary with statistics
  summary,
}

/// Log message that can be sent to Flutter for debugging.
///
/// This struct represents a single log entry with level, target module,
/// timestamp, and message content. It's designed to be sent across the FFI
/// boundary to Flutter for display in the debug console.
class LogMessage {
  /// Log level (TRACE, DEBUG, INFO, WARN, ERROR)
  final String level;

  /// Module path where the log originated (e.g., "heart_beat::adapters")
  final String target;

  /// Timestamp in milliseconds since Unix epoch
  final BigInt timestamp;

  /// The actual log message
  final String message;

  const LogMessage({
    required this.level,
    required this.target,
    required this.timestamp,
    required this.message,
  });

  @override
  int get hashCode =>
      level.hashCode ^ target.hashCode ^ timestamp.hashCode ^ message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LogMessage &&
          runtimeType == other.runtimeType &&
          level == other.level &&
          target == other.target &&
          timestamp == other.timestamp &&
          message == other.message;
}

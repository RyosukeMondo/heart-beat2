Coospo HW9を活用した決定的ヘルスケアテレメトリシステムの構築：FlutterとRustによる高信頼性アーキテクチャに関する包括的研究報告書1. エグゼクティブサマリー：ヘルスケアソフトウェアにおける決定論的アプローチの必然性モバイルヘルスケアアプリケーションの開発は、単なる情報の表示ツールから、ユーザーの生理学的状態を能動的に変容させるバイオフィードバックループへと進化しています。ユーザーが「計画通りに心拍数を上昇させ、健康を維持する」ことを目的とする場合、そのソフトウェアは医療機器に準ずる信頼性を求められます。本プロジェクトにおいて、Coospo HW9光学式心拍計をセンサーとして採用し、Flutterによる直感的なUIと、Rustによる堅牢なロジックコアを統合するハイブリッドアーキテクチャの採用は、極めて戦略的かつ合理的な判断です。現在のモバイル開発における一般的な課題は、Bluetooth通信やリアルタイム信号処理における「非決定性」です。ガベージコレクション（GC）を伴う高水準言語のみで構築されたシステムは、予期せぬレイテンシや競合状態を引き起こしやすく、これがユーザーのトレーニング体験や安全性への信頼を損なう原因となります。これに対し、本報告書では「決定論的開発（Deterministic Development）」を核とした開発手法を提唱します。これは、Rustの所有権モデルと型システムを活用し、コンパイル時にメモリ安全性と並行処理の正当性を数学的に保証するアプローチです。本報告書は、Coospo HW9のハードウェア特性の詳細な解析から始まり、Flutter Rust Bridge (FRB) v2を用いた最新のクロスプラットフォーム設計、そして「測定の自動化」「容易な検証」「戦略的なテスト（UT, IT, E2E, UAT）」を実現するための具体的な技術選定と実装ロードマップを網羅しています。特に、Linux CLI環境を活用したデバッグ手法の確立は、Android実機へのデプロイというボトルネックを解消し、開発サイクルを劇的に加速させる鍵となります。2. ハードウェア・インターフェース解析とプロトコル仕様：Coospo HW9信頼性の高いシステムを構築するための第一歩は、入力ソースであるハードウェアの特性を完全に掌握することです。Coospo HW9は単なるデータ送信機ではなく、独自のバッテリー特性、通信間隔、センサーの物理的制約を持つアクティブなコンポーネントとして扱わなければなりません。2.1 デバイス仕様と生理学的計測の制約Coospo HW9は、前腕（上腕）に装着する光学式心拍モニター（OHR）であり、従来の手首型デバイスよりも高い精度を提供しつつ、胸部ストラップ型（ECG）の不快感を解消するよう設計されています1。2.1.1 センサー特性とノイズ対策このデバイスは第3世代の光学センサーアレイを搭載しており、血流量の変化（PPG: 光電容積脈波）を検知します1。しかし、PPGは原理的に体動ノイズ（Motion Artifact）の影響を受けやすく、特に激しい運動中には「ケイデンスロック（足の運びのリズムを心拍数と誤認する現象）」が発生するリスクがあります。Rustバックエンドにおいては、HW9から送信される生の値をそのまま信用するのではなく、信号平滑化アルゴリズムや異常値検出ロジックを実装する必要があります。これには、後述するカルマンフィルタなどのDSP（デジタル信号処理）技術が不可欠となります。2.1.2 電源管理と運用リミットHW9は90mAhのリチウム充電式バッテリーを搭載し、最大35時間の連続稼働が可能です1。長時間にわたるトレーニング計画（例：マラソンや長距離サイクリング）をサポートするアプリケーションにおいて、バッテリー切れによるデータロストは許容されません。ソフトウェアは、デバイスのバッテリー残量を常時監視し、危険域（例：15%以下）に達した際にユーザーへ警告を発するロジックを組み込む必要があります。2.2 Bluetooth Low Energy (BLE) サービスアーキテクチャの解剖HW9はBluetooth 5.0およびANT+をサポートしていますが、Androidアプリケーションとの通信にはBLEが主役となります1。開発者は、Bluetooth SIGが定義する標準プロファイル（GATT）を正確に実装する必要があります。2.2.1 Heart Rate Service (UUID 0x180D)システムの核心となるデータストリームです。アプリケーションはHeart Rate Measurement Characteristic (UUID 0x2A37) をサブスクライブ（Notify）する必要があります3。ここで重要なのは、0x2A37はポーリング（Read）ではなく、デバイス側からのプッシュ通知（Notify）であるという点です。これにより、Rust側のアーキテクチャは必然的に非同期（Async）かつイベント駆動型である必要があります。Tokioなどのランタイムを用いて、メインスレッドをブロックすることなく着信パケットを処理し続ける設計が求められます。データパケット構造の解析要件:フラグバイト (Byte 0): パケットの最初のバイトは、後続データの形式を規定します。ビット0は心拍数値がUINT8かUINT16かを決定します。HW9は標準仕様に準拠しており、心拍数が255 BPMを超えない限り通常はUINT8を使用しますが、堅牢なパーサーは両方の形式に対応し、動的に切り替える必要があります。RRインターバル (Bit 4): フラグのビット4がセットされている場合、パケットにはRRインターバル（心拍間隔）のデータが含まれます。これは心拍変動（HRV）の計算に不可欠な生データであり、1/1024秒単位の精度で提供されます5。ユーザーの「健康維持」という目的において、単なる心拍数（BPM）だけでなく、ストレスレベルや回復状態を示唆するHRVの解析は、アプリケーションの付加価値を飛躍的に高める要素となります。2.2.2 Battery Service (UUID 0x180F)信頼性担保のため、Battery Level Characteristic (UUID 0x2A19) の監視は必須です3。これは通常、接続確立時のRead、およびその後のNotifyによって監視されます。Coospo HW9の仕様では35時間の寿命がありますが、経年劣化や充電忘れを考慮し、アプリケーション側で「セッション開始前のバッテリーチェック」を強制するUX（ユーザー体験）設計が推奨されます。2.2.3 Device Information Service (UUID 0x180A)トラブルシューティングとフリート管理のために、Firmware Revision String (UUID 0x2A26) および Manufacturer Name String (UUID 0x2A29) を取得します。将来的にCoospoがファームウェアアップデートを行い、データ形式に微細な変更が生じた場合、このバージョン情報を基にパースロジックを分岐させる「Quirk（癖）対応」の実装が可能になります2。2.3 独自拡張と制御ロジックへの対応調査資料によると、HW9は「CoospoRide」や「Heartool」アプリと連携し、振動アラートやLEDのカスタマイズが可能です1。これらの制御は標準GATTには含まれておらず、独自の128-bit UUIDを持つプライベートサービス経由で行われている可能性が高いです。しかし、本プロジェクトの目的である「計画的な心拍上昇」を実現するためには、ハードウェア側のLED制御（リバースエンジニアリングが必要で不安定要素になり得る）に依存するよりも、スマートフォンの画面と音声（Text-to-Speech）を主たるフィードバック手段とし、HW9を純粋な入力デバイスとして扱う設計が、開発の確実性と「検証の容易さ」の観点から推奨されます。3. アーキテクチャブループリント：Flutter Rust Bridge (FRB) v2によるハイブリッド構成「Keynote-level（基調講演レベル）」の品質と、業界標準の堅牢性を両立させるためには、従来のFlutter標準手法であるMethodChannelを超えたアプローチが必要です。ここでは、Flutter Rust Bridge (FRB) v2を採用し、型安全かつ高性能な結合を実現します7。3.1 技術選定の根拠と戦略的意義FlutterとRustの組み合わせは、モバイル開発における「二律背反（UIの柔軟性とロジックの安全性）」を解決する唯一の解です。特性Flutter (Dart)Rust統合によるメリット主用途UIレンダリング、ユーザー操作ビジネスロジック、信号処理、BLE通信UIの滑らかさと計算の正確性の両立メモリ管理ガベージコレクション (GC)所有権モデル (GCなし)リアルタイム処理中にGC停止が発生しない並行処理Isolate (シングルスレッドベース)スレッド、Async/Await (Tokio)重い計算処理でUIスレッドをブロックしない型システム強い静的型付け非常に強い静的型付け + ライフタイム言語間での型不一致によるバグを排除3.2 FRB v2による実装戦略FRB v2は、RustコードをあたかもDartのネイティブライブラリであるかのように扱えるようにする革新的なツールです7。コード生成の自動化: 開発者はRust側でAPI (api.rs) を定義するだけで済みます。FRBは、これに対応するDartコードと、両者を繋ぐC言語のグルーコード（FFIバインディング）を自動生成します。これにより、手動でのバインディング記述によるヒューマンエラーが完全に排除されます。非同期ランタイムの統合: Rust側ではTokioランタイムが駆動します。FlutterからRustの関数を呼び出す際、それはDartのFutureとして扱われ、Rust側のasync fnが完了すると自動的に解決されます7。これは、BLEのスキャンや接続といった長時間実行プロセスにおいて、UIのフリーズ（ANR）を防ぐために不可欠です。StreamSinkによるリアルタイムデータフロー: 心拍データのような連続的なストリームに対しては、StreamSinkパターンを採用します。Rust側でパースされた心拍データはSinkにプッシュされ、Dart側では標準的なStream<HeartRateData>として受け取ります。これにより、FlutterのStreamBuilderウィジェットを用いたリアクティブなUI更新が可能となり、ボイラープレートコードを大幅に削減できます9。3.3 ヘキサゴナルアーキテクチャの適用本システムでは、ビジネスロジックをRust層に隔離する「ヘキサゴナルアーキテクチャ（Ports and Adapters）」を採用します。ドメイン（Rust）: 心拍ゾーンの計算、トレーニング計画の管理、信号フィルタリング。ここはUIやOSに依存せず、純粋なRustコードとして記述されます。ポート（Rust Traits）: 外部とのインターフェース定義（例：BleAdapter, NotificationPort）。アダプター（Rust/Flutter）:Infrastructure Adapter: btleplugを用いたBLE通信の実装。UI Adapter: FRB v2を経由したFlutterへのデータ提供。この構造により、後述する「Linux CLIでのデバッグ」が可能になります。UIアダプターをCLIアダプターに差し替えるだけで、同じドメインロジックをPC上で実行・検証できるからです。4. 決定的コアロジック：Rustによる実装詳細「決定的開発（Deterministic Development）」の要となるのがRust層の実装です。ここでは、曖昧さを排除し、入力に対して常に予測可能な出力を保証するメカニズムを構築します。4.1 信号処理とノイズ除去：Cardio-rsとカルマンフィルタ光学センサーからの生データはノイズを含みます。ユーザーが腕を振ったり、階段を登ったりした際の振動が測定値に干渉するため、「容易な検証」と「品質保証」のためには、生データをそのまま信用することはできません。4.1.1 cardio-rs による高度な解析cardio-rsクレートを採用し、HRV解析機能を実装します5。このライブラリはno_std（標準ライブラリ非依存）環境向けに設計されており、組み込みシステム並みの効率性を持ちます。RMSSD / SDNN計算: 心拍変動の指標をリアルタイムで計算します。これにより、「心拍数は目標値だが、HRVが極端に低下している（疲労困憊）」といった高度な健康状態の推論が可能になります。RRインターバルの補正: HW9から送られてくるRRインターバルの欠落や異常値を検出し、補間するロジックを提供します。4.1.2 1次元カルマンフィルタの実装kalman_filtersクレートを用いて、測定値の平滑化を行います12。移動平均フィルタと比較して、カルマンフィルタは「予測」と「更新」のステップを持つため、急激な心拍上昇（運動開始時）への追従性と、スパイクノイズ（接触不良など）の除去能力のバランスに優れています。状態変数: 真の心拍数、心拍変化率。観測ノイズ: 光学センサーの特性に合わせて動的に調整（加速度センサーの値が取れれば連動させることも可能ですが、今回は純粋な時系列データとして処理）。4.2 階層的ステートマシン (HSM) による状態管理トレーニングセッションの状態管理には、ブール値のフラグ（例: is_running, is_paused）を乱立させるのではなく、形式手法に基づいたステートマシンを導入します。これにより、不正な状態遷移（例：未接続状態でトレーニングを開始する）をコンパイルレベルで阻止できます。4.2.1 ライブラリ選定：statig vs smlang調査に基づき、以下の比較検討を行いました。smlang: DSL（ドメイン特化言語）を用いた記述が特徴で、視認性が高い14。statig: 階層的ステートマシン（HSM）をサポートし、非同期アクションとの親和性が高い16。結論: 本プロジェクトでは statig を採用します。理由は、接続状態（親状態）の中にさらに詳細なサブ状態（スキャン中、接続試行中、認証中）を持つ階層構造がBLE通信の管理に適しているためです。また、Rustの型システムを活用したTypestateパターンに近い安全性を提供します。ステート定義の例:Idle (待機)Connectivity (通信)ScanningConnectingDiscoveringServicesSession (セッション)WarmUp (ゾーン1目標)Work (ゾーン3/4目標)Recovery (ゾーン2目標)Pausedstatigを使用することで、例えば「Session中の切断イベント」が発生した場合、即座にIdleに戻るのではなく、一時的なReconnecting状態に遷移し、自動復帰を試みるといった複雑なロジックを、可読性を維持したまま実装できます。4.3 決定論的スケジューリングとプラン実行ユーザーの要望である「計画通りの心拍上昇」を実現するには、正確なタイミング制御が必要です。sleep()関数のような単純な遅延処理は、OSの負荷によって時間がずれる（ドリフトする）ため不適切です。Rust層で tokio-cron-scheduler または job_scheduler_ng を採用します18。プラン定義: JSON形式で定義されたトレーニングメニュー（例: 「3分間のウォームアップ後、心拍数140以上を10分維持」）を読み込みます。ティック処理: スケジューラは1秒ごとのティック（鼓動）を生成し、現在時刻とプランを照合します。フィードバックループ:目標: 150 BPM現在値 (カルマンフィルタ後): 130 BPM判定: 目標未達 (-20 BPM)アクション: RustからFRB経由でNotification::IncreasePaceイベントを発火。Flutter側でこれを検知し、音声ガイドを再生。このロジックは、AndroidのバックグラウンドサービスとしてRustプロセスが生存している限り、UIの状態に関わらず正確に実行されます。5. 接続性とプラットフォーム戦略：Linux開発とAndroid製品化「Linux CLI debug」と「Android app product」という要件を満たすため、クロスプラットフォームなBLEライブラリの選定と抽象化層の設計が重要になります。5.1 BLEライブラリの選定と「アダプターパターン」Rustエコシステムには主要なBLEライブラリがいくつか存在しますが、Android対応状況にはばらつきがあります。ライブラリ特徴Android対応状況採用判断btleplugオープンソース標準、マルチプラットフォームJNI経由で対応。ただしNPEやスレッド問題の報告あり21第一候補（開発・検証用）simplersble企業のバックアップあり、安定性重視エンタープライズグレードのAndroid対応を謳う23製品版バックアップ（安定性重視）bluestApple系に強いAndroid対応は計画段階25採用見送り戦略: btleplugを基本としつつ、インターフェースを抽象化します。Rust内でBleAdapterトレイトを定義し、開発初期はLinux上でbtleplug（BlueZバックエンド）を使用してロジックを検証します。Android実機テスト（UAT）段階でbtleplugの安定性に問題が生じた場合、ドメインロジックを変更することなく、下位層の実装をsimplersble（またはJava側で実装しFRBで叩くカスタム実装）に差し替えられる設計にします。5.2 Linux CLIによるデバッグと検証の容易化「Verify easily（容易な検証）」を実現する最大の武器がLinux CLIです。Androidエミュレータは起動が遅く、BLEのパススルー機能も不安定な場合が多いです。CLIツールの実装 (bin/cli.rs):Rustプロジェクト内に、FRBに依存しないCLIバイナリを含めます。スキャン実行: LinuxマシンのBluetoothアダプタを使用してHW9を検索。接続・購読: 心拍データを受信し、コンソールにリアルタイム表示。ロジック検証: 受信データに対してカルマンフィルタやステートマシンを適用し、その挙動をログ出力。これにより、開発者はコードの修正から検証までの「インナーループ」を数秒単位に短縮できます。また、CI環境（GitHub Actions上のLinuxランナーなど）でも、Bluetoothスタックのモックを使用することで、統合テストを自動化できます26。5.3 Android統合における課題と解決策AndroidにおけるRust実行（JNI/NDK）には固有の課題があります。権限管理: Bluetoothの使用にはBLUETOOTH_SCAN, BLUETOOTH_CONNECT, ACCESS_FINE_LOCATIONなどのRuntime Permissionが必要です。これはRust側からは直接扱えないため、Flutter側で許可を取得し、その結果をRust側に通知するフローを確立します。バックグラウンド実行: Androidはバックグラウンドアプリのプロセスを積極的にキルします。Rustロジックを維持するためには、AndroidのForeground Service（通知を伴う常駐サービス）として実装する必要があります。Flutter側でflutter_background_service等のプラグインを用い、Rustのランタイムをそのサービス内でホストする構成をとります。6. 戦略的品質保証 (QA) とテスト自動化エコシステム「Stratigically（戦略的に）」テストを行うため、従来の単体テストに加え、プロパティベーステスト、実機自動操作テスト、そして計測の自動化を導入します。6.1 テストピラミッドの再構築6.1.1 Unit Testing (UT): プロパティベーステストの導入従来の「入力Aに対して出力B」を確認するテストだけでは、無限にある入力パターン（異常なBLEパケットなど）を網羅できません。proptest クレートを導入し、プロパティベーステストを行います27。定義: 「どのようなバイト配列が入力されても、パース関数はパニックを起こさず、かつResult型を返すこと」実行: proptestは数千パターンのランダムなデータを生成し、エッジケース（空データ、境界値、不正なフラグ）を自動的に探索します。これにより、予期せぬクラッシュを未然に防ぎます。また、ハードウェアに依存しないテストを行うため、mockall を使用してBleAdapterトレイトをモック化します29。これにより、「接続が切れた瞬間にバッテリーレベルが通知される」といった稀な競合状態をシミュレーションテスト（IT）で再現可能です。6.1.2 End-to-End (E2E): Patrolによるネイティブ統合テストFlutter標準のintegration_testパッケージは、アプリ内のウィジェット操作は可能ですが、OSが表示する「Bluetoothの使用を許可しますか？」というネイティブダイアログを操作できません。本プロジェクトでは Patrol を採用します30。グレーボックステスト: PatrolはDartコードから直接ネイティブビュー（AndroidのUI要素）を操作できます。シナリオ:アプリ起動「接続」ボタンタップOSの権限ダイアログを自動で「許可」（これがPatrolの強み）モック化されたRustバックエンドが「接続成功」イベントを発行UIが「計測中」画面に遷移することを検証6.1.3 User Acceptance Testing (UAT) と実地検証UATにおいては、実際のトレーニング環境での動作確認が必要です。しかし、デバッグログを確認するためにPCを背負って走るわけにはいきません。ログ転送戦略: Rust側のtracingライブラリで出力されたログを、FRB経由でFlutter側にストリーム転送し、ファイルに保存、または開発者向け画面に表示する機能を実装します10。これにより、フィールドテスト中に発生した異常（切断、値の飛躍）を事後解析可能にします。6.2 測定の自動化 (Measurement Automation)品質を定量的に管理するためのメトリクスをCIパイプラインに組み込みます。カバレッジ測定: cargo-tarpaulin を使用してRustコードのテストカバレッジを測定します32。CI（GitHub Actions）上で実行し、カバレッジが閾値（例: 80%）を下回った場合にマージをブロックするルールを設けます。バイナリサイズ監視: モバイルアプリにおいてバイナリサイズは重要です。cargo-size や bencher を使用し、プルリクエストごとのバイナリサイズの増減を追跡します33。意図しない巨大な依存ライブラリの混入を早期に発見します。再現可能なビルド: 開発者の環境依存（"It works on my machine"）を排除するため、Dockerコンテナ内でビルドを行うフローを確立します。これにより、Linux CLIでのデバッグ結果と、CIでのテスト結果、そしてリリースバイナリの挙動の一貫性を保証します35。7. 実装ロードマップと依存関係定義7.1 Rust依存関係グラフ (Cargo.toml)本プロジェクトの戦略を実現するための具体的な依存ライブラリ構成案です。Ini, TOML[package]
name = "coospo_core"
version = "0.1.0"
edition = "2024"

[dependencies]

# 非同期ランタイムと基本機能

tokio = { version = "1", features = ["full"] }
flutter_rust_bridge = "2"
anyhow = "1"
serde = { version = "1", features = ["derive"] }

# BLE通信 (アダプタパターンでラップして使用)

btleplug = "0.11"
uuid = "1"

# 信号処理・数学 (決定的ロジックの中核)

cardio-rs = "0.1" # HRV解析
kalman_filters = "0.1" # ノイズ除去

# 状態管理 (堅牢なステートマシン)

statig = "0.3" # 階層的ステートマシン

# スケジューリング (プラン実行)

tokio-cron-scheduler = "0.13"

# ロギング・トレーシング

tracing = "0.1"

[dev-dependencies]

# テスト戦略用

mockall = "0.13" # モック作成
proptest = "1.5" # プロパティベーステスト
7.2 段階的実装フェーズフェーズ 1: コアロジックとCLI検証 (Linux)Rustプロジェクトのセットアップ。btleplugを用いたBLEスキャナの実装。Coospo HW9のパケットパーサーの実装とproptestによる検証。Linux CLIツールの完成。フェーズ 2: Flutter/Rust ブリッジ構築FRB v2によるコード生成環境の構築。Android権限周りのFlutter実装。心拍データストリームの貫通テスト。フェーズ 3: ドメインロジックの実装cardio-rsとカルマンフィルタの統合。statigによるトレーニングセッションステートマシンの実装。スケジューラによる通知トリガーの実装。フェーズ 4: E2Eテストと最適化PatrolによるUIテストの記述。cargo-tarpaulinによるカバレッジ確認。実機フィールドテストとパラメータ調整。8. 結論本報告書で提示したアーキテクチャは、Coospo HW9という特定のハードウェアを活用しつつ、ソフトウェア工学における最高水準の信頼性を追求するものです。FlutterとRustの統合は、モバイルヘルスケアアプリ開発における新たな「業界標準」となり得るポテンシャルを秘めています。決定論的な信号処理、形式的な状態管理、そして自動化された検証プロセスを組み合わせることで、開発者は「動くかどうかわからない」不安から解放され、「正しく動くことが証明された」システムの上で、ユーザーの健康増進という本来の価値提供に集中することが可能になります。提案されたライブラリ群（FRB v2, Tokio, Statig, Patrol, Proptest）の組み合わせは、2025年時点における最も洗練された技術スタックの一つであり、長期的な保守性と拡張性を保証します。(補足資料: データパースロジックの概念実証)以下は、4の仕様に基づき、Rustで安全に心拍データをパースし、proptestで検証可能な構造の例です。Rust// HW9の心拍データを表現する構造体

#

pub struct HeartRateMeasurement {
pub bpm: u16,
pub rr_intervals: Vec<u16>,
pub sensor_contact: bool,
}

// 安全なパース関数
pub fn parse_heart_rate(data: &[u8]) -> Result<HeartRateMeasurement, anyhow::Error> {
if data.is_empty() {
return Err(anyhow::anyhow!("Empty data"));
}

    let flags = data;
    let is_uint16 = (flags & 0x01)!= 0;
    let contact_supported = (flags & 0x04)!= 0;
    let contact_detected = if contact_supported { (flags & 0x02)!= 0 } else { false };
    let rr_present = (flags & 0x10)!= 0;

    let mut cursor = 1;

    // BPMの読み取り (範囲チェック付き)
    let bpm = if is_uint16 {
        if data.len() < cursor + 2 { return Err(anyhow::anyhow!("Data too short for UINT16 BPM")); }
        let val = u16::from_le_bytes([data[cursor], data[cursor+1]]);
        cursor += 2;
        val
    } else {
        if data.len() < cursor + 1 { return Err(anyhow::anyhow!("Data too short for UINT8 BPM")); }
        let val = data[cursor] as u16;
        cursor += 1;
        val
    };

    // RRインターバルの読み取り
    let mut rr_intervals = Vec::new();
    if rr_present {
        while cursor + 2 <= data.len() {
            let rr = u16::from_le_bytes([data[cursor], data[cursor+1]]);
            rr_intervals.push(rr);
            cursor += 2;
        }
    }

    Ok(HeartRateMeasurement { bpm, rr_intervals, sensor_contact: contact_detected })

}
このコードに対し、proptestを用いて任意のバイト列を与え、決してパニック（配列外参照など）が起きないことを保証するのが、本プロジェクトにおける「Quality Assurance」の第一歩となります。End of Report.
